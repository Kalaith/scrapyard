// events.rs - Event Bus and UI Events for decoupled game logic

/// UI Events generated by input handling
#[derive(Debug, Clone)]
pub enum UIEvent {
    /// Repair a module at the given grid coordinate
    Repair(usize, usize),
    /// Upgrade a module at the given grid coordinate
    Upgrade(usize, usize),
    /// Toggle a module online/offline at the given grid coordinate
    Toggle(usize, usize),
    /// Pause the game
    Pause,
    /// Resume the game
    Resume,
    /// Activate the engine (triggers escape sequence)
    ActivateEngine,
    /// Return to main menu
    ReturnToMenu,
    /// Start a new game
    StartGame,
}

/// Game events for internal state changes (can be used for audio, particles, etc.)
#[derive(Debug, Clone)]
pub enum GameEvent {
    /// Module was repaired
    ModuleRepaired { x: usize, y: usize, cost: i32 },
    /// Module was upgraded
    ModuleUpgraded { x: usize, y: usize, new_level: u8 },
    /// Module was destroyed
    ModuleDestroyed { x: usize, y: usize },
    /// Enemy was killed
    EnemyKilled { x: f32, y: f32, scrap_dropped: i32 },
    /// Enemy reached and damaged a module
    ModuleDamaged { x: usize, y: usize, damage: f32 },
    /// Core took damage
    CoreDamaged { damage: f32, remaining_hp: f32 },
    /// Engine activated - escape sequence started
    EngineActivated,
    /// Escape successful
    EscapeSuccess,
    /// Game over - core destroyed
    CoreDestroyed,
    /// Weapon fired a projectile
    WeaponFired { x: f32, y: f32 },
}

/// Event bus for decoupling UI input from game logic updates
pub struct EventBus {
    ui_events: Vec<UIEvent>,
    game_events: Vec<GameEvent>,
}

impl EventBus {
    pub fn new() -> Self {
        Self {
            ui_events: Vec::new(),
            game_events: Vec::new(),
        }
    }

    /// Push a UI event to be processed
    pub fn push_ui(&mut self, event: UIEvent) {
        self.ui_events.push(event);
    }

    /// Push a game event (for audio/visual feedback)
    pub fn push_game(&mut self, event: GameEvent) {
        self.game_events.push(event);
    }

    /// Drain all UI events for processing
    pub fn drain_ui(&mut self) -> Vec<UIEvent> {
        std::mem::take(&mut self.ui_events)
    }

    /// Drain all game events for processing
    pub fn drain_game(&mut self) -> Vec<GameEvent> {
        std::mem::take(&mut self.game_events)
    }

    /// Check if there are pending UI events
    pub fn has_ui_events(&self) -> bool {
        !self.ui_events.is_empty()
    }

    /// Check if there are pending game events
    pub fn has_game_events(&self) -> bool {
        !self.game_events.is_empty()
    }

    /// Clear all events
    pub fn clear(&mut self) {
        self.ui_events.clear();
        self.game_events.clear();
    }
}
